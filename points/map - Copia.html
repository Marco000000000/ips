<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="">
	<title>ISP</title>
	<link rel="stylesheet" href="static/css/bootstrap.min.css" rel="stylesheet">
	<script src="static/js/bootstrap.bundle.min.js"></script>
	<meta name="theme-color" content="#712cf9">
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css"
		integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ=="
		crossorigin="" />
	<script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"
		integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw=="
		crossorigin=""></script>
	<script src="static/js/Leaflet.ImageOverlay.Rotated.js"></script>
	<script src="static/js/jquery-3.3.1.js"></script>
	<script src="static/js/perspective-transform.js" type="text/javascript"></script>
	<style>
		.bd-placeholder-img {
			font-size: 1.125rem;
			text-anchor: middle;
			-webkit-user-select: none;
			-moz-user-select: none;
			user-select: none;
		}

		@media (min-width: 768px) {
			.bd-placeholder-img-lg {
				font-size: 3.5rem;
			}
		}

		.b-example-divider {
			height: 3rem;
			background-color: rgba(0, 0, 0, .1);
			border: solid rgba(0, 0, 0, .15);
			border-width: 1px 0;
			box-shadow: inset 0 .5em 1.5em rgba(0, 0, 0, .1), inset 0 .125em .5em rgba(0, 0, 0, .15);
		}

		.b-example-vr {
			flex-shrink: 0;
			width: 1.5rem;
			height: 100vh;
		}

		.bi {
			vertical-align: -.125em;
			fill: currentColor;
		}

		.nav-scroller {
			position: relative;
			z-index: 2;
			height: 2.75rem;
			overflow-y: hidden;
		}

		.nav-scroller .nav {
			display: flex;
			flex-wrap: nowrap;
			padding-bottom: 1rem;
			margin-top: -1px;
			overflow-x: auto;
			text-align: center;
			white-space: nowrap;
			-webkit-overflow-scrolling: touch;
		}
	</style>
	<link href="static/css/cover.css" rel="stylesheet">
</head>

<body class="d-flex h-100 text-center text-bg-dark">

	<div class="cover-container d-flex w-100 h-100 p-3 mx-auto flex-column">
		<header class="mb-auto">
			<div style="text-align: center;">
				<h1>Indoor Positioning System</h1>
			</div>
		</header>
		<main class="px-3">
			<div class="row" id="corpo">
				<div class="col">
					<div id="map" style='width:100%; height:600px;'></div>
				</div>
			</div>
			<br>
			<div class="row" id="bottoni">
				<div class="col">
					<input id="get-markers" type="button" value="Esporta punti" class="btn btn-info" />
				</div>


			</div>
			Opacità Planimetria:
			<div class="row">
				<div class="col-1">
					<button class="btn btn-outline-light" onclick='setOverlayOpacity(0.1)'>10%</button>
				</div>
				<div class="col"></div>
				<div class="col-1">
					<button class="btn btn-outline-light" onclick='setOverlayOpacity(0.2)'>20%</button>
				</div>
				<div class="col"></div>
				<div class="col-1">
					<button class="btn btn-outline-light" onclick='setOverlayOpacity(0.3)'>30%</button>
				</div>
				<div class="col"></div>
				<div class="col-1">
					<button class="btn btn-outline-light" onclick='setOverlayOpacity(0.4)'>40%</button>
				</div>
				<div class="col"></div>
				<div class="col-1">
					<button class="btn btn-outline-light" onclick='setOverlayOpacity(0.5)'>50%</button>
				</div>
				<div class="col"></div>
				<div class="col-1">
					<button class="btn btn-outline-light" onclick='setOverlayOpacity(0.6)'>60%</button>
				</div>
				<div class="col"></div>
				<div class="col-1">
					<button class="btn btn-outline-light" onclick='setOverlayOpacity(0.7)'>70%</button>
				</div>
				<div class="col"></div>
				<div class="col-1">
					<button class="btn btn-outline-light" onclick='setOverlayOpacity(0.8)'>80%</button>
				</div>
			</div>
		</main>
		<footer class="mt-auto text-white-50">
			<p>Create by
			<p class="text-white">Papa Andrea Valentino </p>
			</p>
		</footer>
	</div>


	<script type="text/javascript">

		var markers_displayed = false;
		
		const btnm = document.getElementById("btnm");
		//btnm.addEventListener('click', showMarkers)

		function getParameterByName(name) {
			name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
			var regex = new RegExp("[\\?&]" + name + "=([^&#]*)");
			var results = regex.exec(location.search);
			return results == null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
		}

		var lat = parseFloat(getParameterByName('lat'));
		var lon = parseFloat(getParameterByName('lon'));

		// Recupera l'array da localStorage
		const storedArray = localStorage.getItem('Markers');
		const url = localStorage.getItem('my-image');
		const img = new Image();
		img.src = url;
		var imageSize = [0, 0]
		imageSize[0] = parseInt(localStorage.getItem('imgW'));
		imageSize[1] = parseInt(localStorage.getItem('imgH'));
		
		
		var data;
		if (storedArray)
		{
			// Converte la stringa JSON in un array
			data = JSON.parse(storedArray);
			console.log(data);
		}
		else
		{
			console.log('Nessun array salvato.');
		}

		var pointMarkers = [];
		var map = new L.Map('map');


		var positron = L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
			attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
			maxNativeZoom: 18,
			maxZoom: 24
		}).addTo(map);

		var point1 = L.latLng(lat, lon - 0.0006),
			point2 = L.latLng(lat, lon),
			point3 = L.latLng(lat - 0.0006, lon - 0.0006);

		var marker1 = L.marker(point1, { draggable: true }).addTo(map),
			marker2 = L.marker(point2, { draggable: true }).addTo(map),
			marker3 = L.marker(point3, { draggable: true }).addTo(map);


		var bounds = new L.LatLngBounds(point1, point2).extend(point3);

		map.fitBounds(bounds);

		var overlay = L.imageOverlay.rotated(img, point1, point2, point3, {
			opacity: 0.4,
			interactive: true,
			attribution: "Historical building plan &copy; <a href='http://www.ign.es'>Instituto Geográfico Nacional de España</a>"
		});

		showMarkers();

		function repositionImage() {
			const m1c = marker1.getLatLng();
			const m2c = marker2.getLatLng();
			const m3c = marker3.getLatLng();

			console.log("M1", m1c, "M2", m2c);
			overlay.reposition(m1c, m2c, m3c);

			const minLng = Math.min(m1c.lng, m2c.lng, m2c.lng)
			const minLat = Math.min(m1c.lat, m2c.lat, m2c.lat)

			const topLeft    = [m1c.lng - minLng, m1c.lat - minLat]
			const topRight   = [m2c.lng - minLng, m2c.lat - minLat]
			const bottomLeft = [m3c.lng - minLng, m3c.lat - minLat]
			const bottomRight = [topRight[0] - topLeft[0] + bottomLeft[0], topRight[1] - topLeft[1] + bottomLeft[1]]

			const srcCorners = [ 0,0, imageSize[0],0, 0,imageSize[1], imageSize[0],imageSize[1] ]
			const dstCorners = topLeft.concat(topRight).concat(bottomLeft).concat(bottomRight);
			const perspT = PerspT(srcCorners, dstCorners);

			for (let i = 0; i < pointMarkers.length; i++) {
				const dstPt = perspT.transform(data[i].x_Real, data[i].y_Real);
				pointMarkers[i].setLatLng([dstPt[1] + minLat, dstPt[0] + minLng]);
			}
		};

		marker1.on('drag dragend', repositionImage);
		marker2.on('drag dragend', repositionImage);
		marker3.on('drag dragend', repositionImage);

		map.addLayer(overlay);


		function setOverlayOpacity(opacity) {
			overlay.setOpacity(opacity);
		}


		function convertImageCoordinatesToGPS(x, y, imageBounds) {
			var latTopLeft = imageBounds[0][0];
			//console.log(latTopLeft);
			var lngTopLeft = imageBounds[0][1];
			//console.log(lngTopLeft);
			var imageWidth = imageSize[0];
			//console.log(imageWidth);
			var imageHeight = imageSize[1];
			//console.log(imageHeight);
			var lng = lngTopLeft + (x / imageWidth) * (imageBounds[1][1] - lngTopLeft);
			//console.log(lng);
			var lat = latTopLeft - (y / imageHeight) * (latTopLeft - imageBounds[1][0]);
			//console.log(lat);
			return [lat, lng];
		}


		function showMarkers() {
			if (markers_displayed) {
				// TODO remove
				// markers_displayed = false
				return;
			} 

			markers_displayed = true;
			
			for (let j = 0; j < data.length; j++) {
				var xreal = data[j].x_Real;
				var yreal = data[j].y_Real;
				var m1 = cordimark(marker1);
				imageBounds = [[m1[0], m1[1]], quarto_punto()];
				var newp = (convertImageCoordinatesToGPS(xreal, yreal, imageBounds));
				
				let marker = L.circleMarker([newp[0], newp[1]], { radius: 4, fill: true, fillOpacity: 1, stroke: false, fill: true, weight: 0, opacity: 0 }).addTo(map);
				pointMarkers.push(marker)
			}
		}

		/*
		function rimuoviMarker(mappa)
		{
				mappa.eachLayer(function (layer) {
				if (layer instanceof L.Marker)
				{
						console.log(layer);
					mappa.removeLayer(layer);
				}
			});
		}
		*/


		function calculateFourthPoint(lat1, lon1, lat2, lon2, lat3, lon3) {
			const R = 6371; // Raggio approssimativo della Terra in km

			// Converti le coordinate in radianti
			const lat1Rad = toRadians(lat1);
			const lon1Rad = toRadians(lon1);
			const lat2Rad = toRadians(lat2);
			const lon2Rad = toRadians(lon2);
			const lat3Rad = toRadians(lat3);
			const lon3Rad = toRadians(lon3);

			// Calcola la distanza tra i punti 1 e 2
			const d12 = 2 * R * Math.asin(Math.sqrt(Math.pow(Math.sin((lat2Rad - lat1Rad) / 2), 2) +
				Math.cos(lat1Rad) * Math.cos(lat2Rad) * Math.pow(Math.sin((lon2Rad - lon1Rad) / 2), 2)));

			// Calcola l'azimut del punto 2 rispetto al punto 1
			const azimuth12 = Math.atan2(
				Math.sin(lon2Rad - lon1Rad) * Math.cos(lat2Rad),
				Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(lon2Rad - lon1Rad)
			);

			// Calcola le coordinate del punto 4
			const lat4Rad = Math.asin(
				Math.sin(lat3Rad) * Math.cos(d12 / R) +
				Math.cos(lat3Rad) * Math.sin(d12 / R) * Math.cos(azimuth12)
			);
			const lon4Rad = lon3Rad + Math.atan2(
				Math.sin(azimuth12) * Math.sin(d12 / R) * Math.cos(lat3Rad),
				Math.cos(d12 / R) - Math.sin(lat3Rad) * Math.sin(lat4Rad)
			);

			// Converti le coordinate in gradi
			const lat4 = toDegrees(lat4Rad);
			const lon4 = toDegrees(lon4Rad);

			return [lat4, lon4];
		}

		// Funzione di utilità per convertire da gradi a radianti
		function toRadians(degrees) {
			return degrees * Math.PI / 180;
		}

		// Funzione di utilità per convertire da radianti a gradi
		function toDegrees(radians) {
			return radians * 180 / Math.PI;
		}

		function quarto_punto() {
			var m1 = cordimark(marker1);
			var m2 = cordimark(marker2);
			var m3 = cordimark(marker3);
			const lat1 = m1[0];
			const lon1 = m1[1];
			const lat2 = m2[0];
			const lon2 = m2[1];
			const lat3 = m3[0];
			const lon3 = m3[1];
			const fourthPoint = calculateFourthPoint(lat1, lon1, lat2, lon2, lat3, lon3);
			return fourthPoint;
		}

		function cordimark(marker) {
			var sm1 = String(marker.getLatLng());
			var i;
			var m1 = "";
			for (i = 7; i < sm1.length - 1; i++) {
				m1 = m1 + sm1[i];
			}
			const lm1 = m1.split(", ");
			var mm1 = new Array();
			mm1[0] = parseFloat(lm1[0]);
			mm1[1] = parseFloat(lm1[1]);
			return mm1;
		}


		// getting all the markers at once
		function getAllMarkers() {
			showMarkers();
			//var allMarkersObjArray = [];//new Array();
			var allMarkersGeoJsonArray = [];//new Array();
			
			//allMarkersObjArray.push(pointMarkers);
			//allMarkersGeoJsonArray.push(JSON.stringify(pointMarkers.toGeoJSON()));

			/*$.each(map._layers, function (ml) {
				//console.log(map._layers)
				if (map._layers[ml].feature) {
					allMarkersObjArray.push(this)
					allMarkersGeoJsonArray.push(JSON.stringify(this.toGeoJSON()))
				}
			})
			*/

			//console.log(allMarkersObjArray);
			//alert("total Markers : " + allMarkersGeoJsonArray.length + "\n\n" + allMarkersGeoJsonArray + "\n\n Also see your console for object view of this array" );

			console.log(pointMarkers);

			var coordi = [];//new Array();
			var i;
			var punti = JSON.parse(storedArray);
			if (pointMarkers.length > 0) {
				for (i = 0; i < pointMarkers.length; i++) {
					var dataa = pointMarkers[i]._latlng;
					console.log(dataa.lat);
					var x2 = data[i].x_Pro;
					var y2 = data[i].y_Pro;
					var idp = data[i].idp;
					var aa = [idp, dataa.lng, dataa.lat, x2, y2];
					coordi.push(aa);
				}
				//console.log(coordi);
				exportToCsvFile(coordi, 'markers.txt');
				//salvarif();
			}
			else {
				alert("Inserisci almeno un punto all'interno della mappa");
			}

		}

		$("#get-markers").on("click", getAllMarkers);

		function exportToCsvFile(dati, nome_file) {
			let csvStr = dati.map(row => row.join(',')).join('\n');
			let dataUri = 'data:text/csv;charset=utf-8,' + csvStr;
			let exportFileDefaultName = nome_file;
			let linkElement = document.createElement('a');
			linkElement.setAttribute('href', dataUri);
			linkElement.setAttribute('download', exportFileDefaultName);
			linkElement.click();
		}

		function salvarif() {
			var mark = [];
			mark.push(cordimark(marker1));
			mark.push(cordimark(marker2));
			mark.push(cordimark(marker3));
			console.log(mark);
			exportToCsvFile(mark, 'rif.txt');
		}
	</script>

</body>

</html>




</html>